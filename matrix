#!/bin/bash

################################################################################
#Title: Matrix
#Author: Tiffani Auer (frieseti@oregonstate.edu)
#Class: OS CS344 - Winter 2019
#Description:
################################################################################

temp="temp$$"
tempmtrx="tempmtrx$$"
temprow="temprow$$"
tempcol="tempcol$$"
tempmean="tempmean$$"
tempsum="tempsum$$"
tempavg="tempavg$$"
left="templeft$$"
right="tempright$$"
tempprod="tempprod$$"



#calls the clean function to clean up temp files at the end of the program, or #
#if the program is interrupted by one of the exceptions represented by the     #
#numbers: 0-exit from shell, 1-clean tidyup, 2-interrupt, 3-quit, 6-abort      #
#trap clean; INT HUP TERM

#dims funct#
function dims(){ 
	l=0
	c=0

	#rows#
	l=$(cat $1 | wc -l)

	#columns#
	c=$(cat $1 | head -n 1 | wc -w)
	
	#print dimensions#
	echo -e  "$l $c"
}

#transpose funct#
function transpose(){
	j=1
	c=0

	#column count#
	c=$(cat $1 | head -n 1 | wc -w)
	
	#column to row conversion
	while [[ "$j" -le "$c" ]]
	do			
		cut -f $j $1 > $tempcol
		truncate -s-1 $tempcol
		cat $tempcol | tr '\n' '\t' >> $temprow
		echo >> $temprow
		((j++))
	done
	
	cat $temprow
}


#mean funct#
function mean(){		
	#use transpose function to invert matrix so we average the correct# 
	#numbers, dump output to temp file so it doesn't print to screen  #
	dump=$(transpose $1)


	#traverse through the matrix#
	while read row
	do
		#reset vars each iteration#
		sum=0
		count=0
		avg=0

		for i in $row
		do
			#add all numbers in matrix#
			sum=$((sum + i))
			((count++))		
		done
		
		#calculate mean#
		avg=$(((sum + (count/2)*((sum>0)*2 - 1) )/count))
		echo "$avg" >> $tempavg
	done <  $temprow
		
		#format means for output and print to screen#
		truncate -s-1 $tempavg	
		cat $tempavg | tr '\n' '\t' >> $tempmean
		echo >> $tempmean
		cat $tempmean
}

#add funct#
function add(){
	lcol=0
	lrow=0
	rcol=0
	rrow=0

	#get dimensions of matrices#	
	lrow=$(cat $1 | wc -l)
	lcol=$(cat $1 | head -n 1 | wc -w)

	rrow=$(cat $2 | wc -l)
	rcol=$(cat $2 | head -n 1 | wc -w)

	#separate the values#
	lft=$(cat $1 | tr '\t' '\n')
	rght=$(cat $2 | tr '\t' '\n') 
	
	#add the matrices#		
	while read lmtrx <&3 && read rmtrx <&4
	do
		sum=$((lmtrx + rmtrx))
		echo $sum > $tempsum
		cat $tempsum | tr '\n' '\t' >> $tempmtrx	
		((k++))

		#add \n for new matrix row#
		if [[ $k -eq  $lcol ]]
		then
			truncate -s -1 $tempmtrx
			echo >> $tempmtrx
			k=0
		fi
	done 3<<< "$lft" 4<<< "$rght"

	cat $tempmtrx
}

#multiply funct#
function multiply(){	
	lcol=0
	lrow=0
	rcol=0
	rrow=0
	prod=1
	m=1
	n=1

	#get dimensions of matrices#	
	lrow=$(cat $1 | wc -l)
	lcol=$(cat $1 | head -n 1 | wc -w)

	rrow=$(cat $2 | wc -l)
	rcol=$(cat $2 | head -n 1 | wc -w)

	#reformat first matrix so formats match#	
	dump=$(transpose $1)
		
	#this works correctly#
	while [[ $m -le $lrow ]]
	do			
		#cycles through the left matrix#
		cut -f $m $temprow > $left

		#cycles through the right matrix and multiplies with corresponding 	#
		#left matrix row							#
		while [[ $n -le $rcol ]]
		do
			cut -f $n $2 > $right
			((n++))
			
			#multiply the matrices#		
			while read lmtrx <&3 && read rmtrx <&4
			do
				prod=$((lmtrx * rmtrx))
				sum=$((sum + prod))
			done 3< $left 4< $right				
				
			echo $sum | tr '\n' '\t' >> $tempmtrx	
			prod=1
			sum=0
		done
		truncate -s-1 $tempmtrx
		echo >> $tempmtrx
		n=1
		((m++))	
	done
	
	cat $tempmtrx
}


#readMatrix funct: it's for me, not you ;)#
function readmtrx(){
while read mtrx
do
	echo "$mtrx"
done < $1

}

#removes temporary files#
clean(){
	rm -f *$$
}


main(){
 
#validate input and call functions#
case $1 in
	dims)
		#gives input from stdin permanency#
		cat $2 > $temp

		if [[ -f $3 ]]
		then
			echo "dims goes dark with more than one matrix." >&2
			clean
			exit 1
		elif [ ! -f $temp ] || [ ! -s $temp  ]
		then
			echo "yo' file is broke." >&2
			clean
			exit 1
		else
			dims $temp
		fi

	;;
	transpose)

		if [[ -f $3 ]]
		then
			echo "more than one matrix makes transpose cry." >&2
			clean
			exit 1
		elif [[ ! -r $2 ]]
		then
			echo "your file in unreadable, son!" >&2
			clean
			exit 1
		else
			transpose $2
		fi
	;;
	mean)
		if [[ -f $3  ]]
		then
			echo "we are finding the average of one matrix, not the entire neighborhood! Geeze." >&2
			clean
			exit 1
		elif [[ ! -r $2 ]]
		then
			echo "i'm tryin' to read, but you gotta give me something, man!" >&2
			clean
			exit 1
		else
			mean $2
		fi
	;;
	add)	
		#get dimensions of matrices#	
		lrow=$(cat $2 | wc -l)
		lcol=$(cat $2 | head -n 1 | wc -w)

		rrow=$(cat $3 | wc -l)
		rcol=$(cat $3 | head -n 1 | wc -w)

	
		if [[ -f $4 ]]
		then
			echo "there are only so many usable seconds in a grading script. why are you giving me more than two matrices?!" >&2
			clean
			exit 1
		elif [ ! -r $2 ] || [ ! -r $3 ]
		then
			echo "check yo' file. I don't understand it." >&2
			clean
			exit 1
		elif [ $lrow -eq 0 ] || [ $rrow -eq 0 ]
		then
			echo "empty files do not make for exciting addition." >&2
			exit 1	
		elif [ $lrow -ne $rrow ] || [ $lcol -ne $rcol ]
		then		
			echo "your matrices are incompatible and will fight if put together." >&2
			exit 1
		else
			add $2 $3
		fi
	;;
	multiply)
		#get dimensions of matrices#	
		lrow=$(cat $2 | wc -l)
		lcol=$(cat $2 | head -n 1 | wc -w)

		rrow=$(cat $3 | wc -l)
		rcol=$(cat $3 | head -n 1 | wc -w)

	
		if [[ -f $4 ]]
		then
			echo "there are only so many usable seconds in a grading script. why are you giving me more than two matrices?!" >&2
			clean
			exit 1
		elif [ ! -r $2 ] || [ ! -r $3 ]
		then
			echo "check yo' file. I don't understand it." >&2
			clean
			exit 1
		elif [ $lrow -eq 0 ] || [ $rrow -eq 0 ]
		then
			echo "empty files do not make for exciting addition." >&2
			exit 1	
	#	elif [ $lrow -ne $rcol ] || [ $lcol -ne $rrow ]
	#	then		
	#		echo "your matrices are incompatible and will fight if put together." >&2
	#		exit 1
		else
			multiply $2 $3
		fi
		
	;;
	readmtrx)
		readmtrx $2
	;;
	#catchall for bad commands#
	*)
		echo "I see what you did there, you saucy minx. Of course, I already thought of that. This program has well defined parameters. Stay in you're lane. ;)" >&2 
		exit 1
	;;
esac 


clean
exit 0
}

#pass arguments from user to main#
main $1 "${@:2}"
 
